Input/Output
  In the Linux everything is a file, in order to exchange information between programs the Linux have File Descriptors
  that is just stardard inputs and standard outputs.
  Everything that is shown in the Bash comes from STDOUT (standard output)
  Everything that is not shown in the Bash because some errors happened is redirect to the STDERR 
  (standard error output)
  Everything that is typed using keybord goes to STDIN (standard input)


File descriptors
  stdin = 0
  stdout = 1
  stderr = 2


Redirects

  > (Redirect to the standard output - (stdout), but truncate existing data)
    ls / > stdout.txt (Will redirect the list of directories and files generated by "ls" command to the file 
                       "stdout.txt", if this file already exists then it will be truncated, otherwise this file will
                       be created and the data will be persisted in there)
  
  >> (Redirect to the standard output - (stdout), will append the redirected data to the end of file)
    ls / >> stdout.txt (Will redirect the list of directories and files generated by "ls" command to the file
                        "stdout.txt", if this file already exists then this new data will be appended at the end of the
                        file, otherwise the file will be created)

  < (Redirect to the standard input - (stdin), will get the content of a given file and send it as parameter to a binary)
    cat < users_list.txt (Will get the "users_list.txt" data and will send it to the "cat" as parameter, in this case
                          the "cat" will just print it but if you use another program you can process this data for 
                          example to send an email for each user in the list)

  << (Redirect to the standard input - (stdin) as well, the main difference is that it will open an interactive editor
      and will be close when the word used as parameter was typed)
    cat << EOF (Will open an interactive cursor in order to receive text data, when you finish to type the text you want
                will type EOF (End Of File) and the redirect will close)

  2> (Redirect to the standard error output - (stderr), but truncate the existing data)
    lsbla / 2> stderr.txt (Will redirect the error message that will be shown in the terminal to the stderr.txt file,
                           if the file exists then it will be truncated and the data will be persisted there, otherwise
                           it will created this file and the data will be persisted there)

  2>> (Redirect to the standard error output - (stderr), but append the data to the end of the file)
    lsbla / 2> stderr.txt (Will redirect the error message that will be shown in the terminal to the stderr.txt file,
                           if the file exists then it the data will be appended at the end of the file, otherwise the 
                           file will be created and the data will be persisted there)

  | (Redirect the output of given command to the input of another command)
    ps -ef | grep root ("ps -ef" Will list all process and will send the output data to the "grep" command using "|"
                        The "grep root" will use the data of "ps -ef" command as input to filter all lines that contains
                        the "root" word)


Redirecting the stderr to the stdout
  ls this-file-does-not-exist this-file-exists > stdout.txt 2>&1 (Will redirect the error for the first file to the 
                                                                  "stdout.txt" instead of printing the error in the
                                                                  terminal, it works because of "2>&1".
                                                                  It means that the error that is redirected to the FD2
                                                                  (2>) will also be redirect to the FD1 (&1)

&& (AND) operator
  && is used to run nested commands in case while the current command have been working i.e:
  command1 && command2 && command3
    If "command1" have been worked then the "command2" will be executed, if "command2" have been worked then the 
    "command3" will be executed and so on.
    If the "command1" fails then the execution process stops and "command2" and "command3" won't be executed anymore.


|| (OR) operator
  || (OR) is the oposite of && (AND) for nested commands, it go to the next command while the current one fails, i.e
  command1 || command2 || command3
    if "command1" fails then the "command2" will be executed, if the "command2" fails then the "command3" will be 
    executed and so on.
    If the "command1" fails and the "command2" works then the "command3" will not be executed anymore.
